#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import generator_stop

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {
    'inductive',
    'obtains',
    'assume',
    'sublocale',
    'synth_definition',
    'print_classes',
    'thm_deps',
    'syntax',
    'export_generated_files',
    'attribute_setup',
    'typedef',
    'sorry',
    'back',
    'subgoal',
    'constrains',
    'presume',
    'check_derivation',
    'print_rules',
    'named_simpset',
    'prepare_code_thms',
    'apply',
    'definition',
    'values',
    'code_pred',
    'print_theory',
    'unbundle',
    'hide_class',
    'interpret',
    'section',
    'setup',
    'partial_function',
    'also',
    'apply_end',
    'prop',
    'is',
    'method_setup',
    '@phantom',
    'functor',
    'quotient_type',
    'no_type_notation',
    'find_consts',
    '.',
    'proof',
    'hoarestate',
    'named_theorems_rev',
    'thy_deps',
    'ML_prf',
    '\\<close>',
    'print_term_bindings',
    'lemmas',
    'old_rep_datatype',
    'print_test',
    'print_simpset',
    'help',
    'primcorecursive',
    'corollary',
    'parse_translation',
    'inductive_cases',
    'thm',
    'SML_export',
    'rewrites',
    'theorem',
    'assumes',
    'print_options',
    'parse_ast_translation',
    'private',
    'print_syntax',
    'print_abbrevs',
    'print_attributes',
    'bibtex_file',
    'code_deps',
    'show',
    '\\<open>',
    'coinductive_set',
    'define',
    'datatype_compat',
    'subsection',
    'realizability',
    'no_notation',
    'thus',
    'prefer',
    'keywords',
    'nominal_datatype',
    'SML_file_no_debug',
    'simproc_setup',
    'sepref_thm',
    'overloading',
    'tycondef',
    'approximate',
    'begin',
    'abbreviation',
    'SML_file',
    'find_theorems',
    'premises',
    'type_notation',
    'lifting_update',
    'class_instance',
    'extract_type',
    'no_translations',
    'consts',
    'print_ML_antiquotations',
    'fixrec',
    'print_codeproc',
    'done',
    'declassify',
    'notes',
    'using',
    'nominal_function',
    'codatatype',
    'case',
    'sepref_decl_op',
    'parametric_constant',
    'bnf_axiomatization',
    'code_lazy_type',
    'circus_process',
    'compile_generated_files',
    'write',
    'alias',
    'includes',
    'ML_export',
    'applyS',
    'record',
    'hence',
    'no_adhoc_overloading',
    'locset_definition',
    'copy_bnf',
    'print_antiquotations',
    'finally',
    'no_syntax',
    'procedure_spec',
    'axiomatization',
    'inductive_set',
    'ML_val',
    'code_thms',
    'qualified',
    'notepad',
    'ML_file',
    'typ',
    'ultimately',
    'quickcheck_params',
    'full_prf',
    'constant',
    'program_spec',
    'fun',
    'print_facts',
    'locale',
    'functions',
    'print_codesetup',
    'including',
    'paragraph',
    'case_of_simps',
    'local_setup',
    'chapter',
    'translations',
    'lemma',
    'sledgehammer_params',
    'nominal_termination',
    'oracle',
    'datatype',
    'txt',
    'concrete_definition',
    'declaration',
    'code_reserved',
    'hide_fact',
    'friend_of_corec',
    'SML_import',
    'print_ast_translation',
    'text',
    'print_state',
    'text_raw',
    'proposition',
    'print_bundles',
    'global_interpretation',
    'with',
    'end',
    'type_alias',
    'instance',
    'record_all_facts',
    'hide_type',
    'and',
    'derive',
    'class_deps',
    'nitpick_params',
    'ML_command',
    'code_datatype',
    'datatypes',
    'fun_cases',
    'in',
    'sepref_decl_intf',
    'print_theorems',
    'external_file',
    'print_trans_rules',
    'quickcheck_generator',
    'class_relation',
    'hide_const',
    'applicative',
    'print_commands',
    'extract',
    'corec',
    'primcorec',
    'export_prefix',
    'code_reflect',
    'memoize_correct',
    'interpretation',
    'defines',
    'consider',
    'procedures',
    'when',
    'preference_profile',
    'external_files',
    'print_locale',
    'class',
    'lift_bnf',
    'sepref_definition',
    'judgment',
    'instantiation',
    'print_applicative',
    '..',
    'print_methods',
    'print_dependencies',
    'for',
    'prf',
    'record_facts',
    'file',
    'print_locales',
    'termination',
    'memoize_fun',
    '\\<proof>',
    'welcome',
    'then',
    'checking',
    'code_module',
    'subsubsection',
    'recursive_spec',
    'supply',
    'lift_definition',
    'print_cases',
    'experiment',
    'fixes',
    'abbrevs',
    'print_statement',
    'ground_function',
    'syntax_declaration',
    'coinductive',
    'shows',
    'lifting_forget',
    'real_limit',
    'typed_print_translation',
    'term',
    'sepref_register',
    'type_constructor',
    'code_printing',
    'oops',
    'note',
    'quickcheck',
    'subclass',
    'by',
    'guess',
    'file_prefix',
    'from',
    'named_theorems',
    'ML',
    'ML_file_debug',
    'schematic_goal',
    'atom_decl',
    'realizers',
    'unused_thms',
    'typedecl',
    'include',
    'where',
    'primrec',
    'inv_definition',
    'qed',
    'applyF',
    'bnf',
    'context',
    'next',
    'locale_deps',
    'generate_file',
    'free_constructors',
    'real_expansion',
    'print_translation',
    'let',
    'print_context',
    'module_name',
    'print_defn_rules',
    'export_code',
    'default_sort',
    'ML_file_no_debug',
    'have',
    'bundle',
    'fix',
    'datatype_record',
    'sepref_decl_impl',
    'method',
    'declare',
    'specification',
    'code_monad',
    'obtain',
    'inductive_simps',
    'type_class',
    'refute_params',
    'corecursive',
    'nominal_primrec',
    'defer',
    'setup_lifting',
    'notation',
    'function',
    'moreover',
    'value',
    'simps_of_case',
    'print_interps',
    'SML_file_debug',
    'apply1',
    'code_identifier',
    'type_synonym',
    'print_definitions',
    'nonterminal',
    'nominal_inductive',
    'adhoc_overloading',
    'if',
    'unfolding',
    'check_derivation_C',
    'export_files',
}  # type: ignore


class ThyBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re='(?P<sb>\\(\\*((?!(\\(\\*|\\*\\)))(.|\\n)|(?P>sb))*\\*\\))|((\\\\<\\^cancel>|\\\\<\\^marker>|\\\\<\\^theory>)(?P<oc>\\\\<open>((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?P>oc))*\\\\<close>))|((\\\\<comment>|txt|text|text_raw|subsection|section|subsubsection)\\s*(?P<tag>%\\s*[A-Za-z][A-Za-z0-9_\'\\.]*)?\\s*(?P>oc))|(?<=( |\\n))(term)([ \\n\\t])+("(.|\\n)*?(?<!\\\\)"|[A-Za-z][A-Za-z0-9_\'\\.]*)|(?P>tag)',
        eol_comments_re=None,
        ignorecase=None,
        namechars="'_.",
        **kwargs
    ):
        super().__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class ThyParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re='(?P<sb>\\(\\*((?!(\\(\\*|\\*\\)))(.|\\n)|(?P>sb))*\\*\\))|((\\\\<\\^cancel>|\\\\<\\^marker>|\\\\<\\^theory>)(?P<oc>\\\\<open>((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?P>oc))*\\\\<close>))|((\\\\<comment>|txt|text|text_raw|subsection|section|subsubsection)\\s*(?P<tag>%\\s*[A-Za-z][A-Za-z0-9_\'\\.]*)?\\s*(?P>oc))|(?<=( |\\n))(term)([ \\n\\t])+("(.|\\n)*?(?<!\\\\)"|[A-Za-z][A-Za-z0-9_\'\\.]*)|(?P>tag)',
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars="'_.",
        tokenizercls=ThyBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            tokenizercls=tokenizercls,
            **kwargs
        )

    @tatsumasu()
    def _start_(self):  # noqa
        self._theory_()
        self._check_eof()

    @tatsumasu('Theory')
    def _theory_(self):  # noqa

        def block1():
            self._text_block_()
        self._closure(block1)
        self.name_last_node('text_blocks')
        self._token('theory')
        with self._group():
            with self._choice():
                with self._option():
                    self._name_()
                with self._option():
                    self._content_double_quotation_()
                self._error('expecting one of: content_double_quotation name')
        self.name_last_node('thy_name')
        self._token('imports')

        def block5():
            self._imported_thy_name_()
        self._positive_closure(block5)
        self.name_last_node('imported_thy_names')
        with self._optional():
            self._thy_keywords_()
        self.name_last_node('keywords')
        with self._optional():
            self._token('abbrevs')

            def block8():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('and')
                        with self._option():
                            self._token('=')
                        with self._option():
                            self._content_open_closed_()
                        with self._option():
                            self._name_()
                        self._error('expecting one of: = and content_open_closed name')
            self._closure(block8)
        self.name_last_node('abbrevs')
        self._token('begin')

        def block11():
            self._theory_statement_()
        self._closure(block11)
        self.name_last_node('thy_stats')
        self._token('end')
        self.ast._define(
            ['abbrevs', 'imported_thy_names', 'keywords', 'text_blocks', 'thy_name', 'thy_stats'],
            []
        )

    @tatsumasu()
    def _thy_keywords_(self):  # noqa
        self._token('keywords')

        def sep0():
            self._token('and')

        def block0():

            def block1():
                self._content_open_closed_()
            self._positive_closure(block1)
            with self._optional():
                self._token('::')
                self._name_()
        self._positive_join(block0, sep0)

    @tatsumasu()
    def _imported_thy_name_(self):  # noqa
        with self._choice():
            with self._option():
                self._long_name_()
            with self._option():
                self._pattern('(")(.)*?(")')
            self._error('expecting one of: /(")(.)*?(")/ /((?P>name)\\.)+(?P<name>([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>))/ /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /-?( )*[0-9]+/ /[\\*_#&$]+/ /\\\\<([A-Za-z][A-Za-z0-9_\']*)>/ content_double_quotation int_str long_name name')

    @tatsumasu()
    def _theory_statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._text_block_()
            with self._option():
                self._theorem_()
            with self._option():
                self._definition_()
            with self._option():
                self._function_()
            with self._option():
                self._termination_()
            with self._option():
                self._locale_class_()
            with self._option():
                self._named_theorems_()
            with self._option():
                self._sublocale_()
            with self._option():
                self._extra_thy_command_()
            with self._option():
                self._context_()
            with self._option():
                self._extra_context_()
            self._error('expecting one of: ML ML_export ML_file ML_val SML_export SML_import abbreviation adhoc_overloading alias applicative approximate atom_decl attribute_setup axiomatization bnf bnf_axiomatization bundle case_of_simps chapter circus_process class codatatype code_datatype code_identifier code_lazy_type code_monad code_pred code_printing code_reflect code_reserved code_thms coinductive coinductive_set compile_generated_files concrete_definition consts context copy_bnf corec corecursive corollary datatype datatype_compat datatype_record declaration declare declassify default_sort definition derive experiment export_code external_file extra_context extra_thy_command extract_type find_consts find_theorems fixrec free_constructors friend_of_corec fun fun_cases function functor generate_file global_interpretation ground_function hide_class hide_const hide_fact hide_type hoarestate inductive inductive_cases inductive_set inductive_simps instance instantiation interpretation inv_definition judgment lemma lemmas lemmas_with lift_bnf lift_definition lifting_forget lifting_update local_setup locale locale_class locset_definition memoize_correct memoize_fun method method_setup named_simpset named_theorems named_theorems_rev nitpick_params no_adhoc_overloading no_notation no_syntax no_translations no_type_notation nominal_datatype nominal_function nominal_inductive nominal_primrec nominal_termination nonterminal notation notepad old_rep_datatype oracle overloading paragraph parametric_constant parse_ast_translation parse_translation partial_function preference_profile prepare_code_thms primcorec primcorecursive primrec print_applicative print_ast_translation print_interps print_locale print_statement print_test print_theorems print_translation private procedure_spec procedures program_spec proposition qualified quanlifier quickcheck_generator quickcheck_params quotient_type real_expansion real_limit realizability realizers record recursive_spec refute_params schematic_goal section sepref_decl_impl sepref_decl_intf sepref_decl_op sepref_definition sepref_register sepref_thm setup setup_lifting simproc_setup simps_of_case sledgehammer_params specification subclass sublocale subsection subsubsection syntax syntax_declaration synth_definition term termination text text_block text_raw theorem thm thy_deps translations tycondef typ type type_alias type_notation type_synonym typed_print_translation typedecl typedef unbundle value values')

    @tatsumasu('ExtraContext')
    def _extra_context_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('instantiation')
                with self._option():
                    self._token('overloading')
                with self._option():
                    self._token('bundle')
                with self._option():
                    self._token('experiment')
                with self._option():
                    self._token('notepad')
                self._error('expecting one of: bundle experiment instantiation notepad overloading')
        self.name_last_node('key')

        def block3():
            with self._group():
                with self._choice():
                    with self._option():
                        self._long_name_()
                    with self._option():
                        self._token('fixes')
                    with self._option():
                        self._token('assumes')
                    with self._option():
                        self._token('where')
                    with self._option():
                        self._token('and')
                    with self._option():
                        self._token('==')
                    with self._option():
                        self._token('=')
                    with self._option():
                        self._token('::')
                    with self._option():
                        self._content_bracket_()
                    with self._option():
                        self._content_square_bracket_()
                    with self._option():
                        self._content_open_closed_()
                    self._error('expecting one of: :: = == and assumes content_bracket content_open_closed content_square_bracket fixes long_name where')
        self._closure(block3)
        self.name_last_node('args')
        with self._optional():
            self._content_begin_end_()
        self.name_last_node('cont')
        self.ast._define(
            ['args', 'cont', 'key'],
            []
        )

    @tatsumasu('ExtraThyCommand')
    def _extra_thy_command_(self):  # noqa
        with self._optional():
            self._quanlifier_()
        self.name_last_node('qualifier')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('record')
                with self._option():
                    self._token('typ')
                with self._option():
                    self._token('quotient_type')
                with self._option():
                    self._token('attribute_setup')
                with self._option():
                    self._token('default_sort')
                with self._option():
                    self._token('local_setup')
                with self._option():
                    self._token('lift_definition')
                with self._option():
                    self._token('consts')
                with self._option():
                    self._token('instance')
                with self._option():
                    self._token('declaration')
                with self._option():
                    self._token('typedecl')
                with self._option():
                    self._token('parse_ast_translation')
                with self._option():
                    self._token('parse_translation')
                with self._option():
                    self._token('hide_type')
                with self._option():
                    self._token('hide_const')
                with self._option():
                    self._token('simproc_setup')
                with self._option():
                    self._token('alias')
                with self._option():
                    self._token('type_alias')
                with self._option():
                    self._token('setup_lifting')
                with self._option():
                    self._token('code_identifier')
                with self._option():
                    self._token('typed_print_translation')
                with self._option():
                    self._token('quickcheck_params')
                with self._option():
                    self._token('quickcheck_generator')
                with self._option():
                    self._token('hide_class')
                with self._option():
                    self._token('hide_fact')
                with self._option():
                    self._token('declare')
                with self._option():
                    self._token('method_setup')
                with self._option():
                    self._token('abbreviation')
                with self._option():
                    self._token('syntax_declaration')
                with self._option():
                    self._token('syntax')
                with self._option():
                    self._token('translations')
                with self._option():
                    self._token('print_translation')
                with self._option():
                    self._token('print_ast_translation')
                with self._option():
                    self._token('oracle')
                with self._option():
                    self._token('unbundle')
                with self._option():
                    self._token('no_translations')
                with self._option():
                    self._token('axiomatization')
                with self._option():
                    self._token('code_datatype')
                with self._option():
                    self._token('code_printing')
                with self._option():
                    self._token('code_reserved')
                with self._option():
                    self._token('code_printing')
                with self._option():
                    self._token('code_reflect')
                with self._option():
                    self._token('type_synonym')
                with self._option():
                    self._token('type_notation')
                with self._option():
                    self._token('no_type_notation')
                with self._option():
                    self._token('datatype')
                with self._option():
                    self._token('notation')
                with self._option():
                    self._token('declare')
                with self._option():
                    self._token('no_notation')
                with self._option():
                    self._token('no_syntax')
                with self._option():
                    self._token('typedef')
                with self._option():
                    self._token('inductive_set')
                with self._option():
                    self._token('inductive')
                with self._option():
                    self._token('free_constructors')
                with self._option():
                    self._token('old_rep_datatype')
                with self._option():
                    self._token('setup')
                with self._option():
                    self._token('global_interpretation')
                with self._option():
                    self._token('interpretation')
                with self._option():
                    self._token('nonterminal')
                with self._option():
                    self._token('lemmas')
                with self._option():
                    self._token('lemmas_with')
                with self._option():
                    self._token('functor')
                with self._option():
                    self._token('judgment')
                with self._option():
                    self._token('realizers')
                with self._option():
                    self._token('realizability')
                with self._option():
                    self._token('extract_type')
                with self._option():
                    self._token('generate_file')
                with self._option():
                    self._token('SML_import')
                with self._option():
                    self._token('SML_export')
                with self._option():
                    self._token('ML_export')
                with self._option():
                    self._token('lifting_forget')
                with self._option():
                    self._token('lifting_update')
                with self._option():
                    self._token('external_file')
                with self._option():
                    self._token('bnf')
                with self._option():
                    self._token('codatatype')
                with self._option():
                    self._token('primcorec')
                with self._option():
                    self._token('primcorecursive')
                with self._option():
                    self._token('thm')
                with self._option():
                    self._token('term')
                with self._option():
                    self._token('type')
                with self._option():
                    self._token('value')
                with self._option():
                    self._token('text_raw')
                with self._option():
                    self._token('lift_bnf')
                with self._option():
                    self._token('coinductive_set')
                with self._option():
                    self._token('parametric_constant')
                with self._option():
                    self._token('partial_function')
                with self._option():
                    self._token('export_code')
                with self._option():
                    self._token('adhoc_overloading')
                with self._option():
                    self._token('no_adhoc_overloading')
                with self._option():
                    self._token('coinductive')
                with self._option():
                    self._token('real_expansion')
                with self._option():
                    self._token('real_limit')
                with self._option():
                    self._token('corec')
                with self._option():
                    self._token('friend_of_corec')
                with self._option():
                    self._token('find_theorems')
                with self._option():
                    self._token('find_consts')
                with self._option():
                    self._token('values')
                with self._option():
                    self._token('schematic_goal')
                with self._option():
                    self._token('inductive_cases')
                with self._option():
                    self._token('code_pred')
                with self._option():
                    self._token('refute_params')
                with self._option():
                    self._token('inductive_simps')
                with self._option():
                    self._token('specification')
                with self._option():
                    self._token('code_monad')
                with self._option():
                    self._token('approximate')
                with self._option():
                    self._token('datatype_record')
                with self._option():
                    self._token('print_test')
                with self._option():
                    self._token('fun_cases')
                with self._option():
                    self._token('code_thms')
                with self._option():
                    self._token('print_theorems')
                with self._option():
                    self._token('case_of_simps')
                with self._option():
                    self._token('simps_of_case')
                with self._option():
                    self._token('method')
                with self._option():
                    self._token('copy_bnf')
                with self._option():
                    self._token('datatype_compat')
                with self._option():
                    self._token('bnf_axiomatization')
                with self._option():
                    self._token('corecursive')
                with self._option():
                    self._token('nitpick_params')
                with self._option():
                    self._token('sledgehammer_params')
                with self._option():
                    self._token('derive')
                with self._option():
                    self._token('applicative')
                with self._option():
                    self._token('print_applicative')
                with self._option():
                    self._token('compile_generated_files')
                with self._option():
                    self._token('concrete_definition')
                with self._option():
                    self._token('atom_decl')
                with self._option():
                    self._token('nominal_datatype')
                with self._option():
                    self._token('nominal_function')
                with self._option():
                    self._token('nominal_termination')
                with self._option():
                    self._token('declassify')
                with self._option():
                    self._token('circus_process')
                with self._option():
                    self._token('locset_definition')
                with self._option():
                    self._token('inv_definition')
                with self._option():
                    self._token('print_interps')
                with self._option():
                    self._token('sepref_register')
                with self._option():
                    self._token('sepref_decl_intf')
                with self._option():
                    self._token('sepref_definition')
                with self._option():
                    self._token('sepref_thm')
                with self._option():
                    self._token('preference_profile')
                with self._option():
                    self._token('fixrec')
                with self._option():
                    self._token('memoize_fun')
                with self._option():
                    self._token('program_spec')
                with self._option():
                    self._token('procedure_spec')
                with self._option():
                    self._token('recursive_spec')
                with self._option():
                    self._token('named_simpset')
                with self._option():
                    self._token('print_locale')
                with self._option():
                    self._token('nominal_inductive')
                with self._option():
                    self._token('nominal_primrec')
                with self._option():
                    self._token('memoize_correct')
                with self._option():
                    self._token('memoize_fun')
                with self._option():
                    self._token('ground_function')
                with self._option():
                    self._token('code_lazy_type')
                with self._option():
                    self._token('sepref_decl_impl')
                with self._option():
                    self._token('sepref_decl_op')
                with self._option():
                    self._token('named_theorems_rev')
                with self._option():
                    self._token('print_statement')
                with self._option():
                    self._token('thy_deps')
                with self._option():
                    self._token('prepare_code_thms')
                with self._option():
                    self._token('procedures')
                with self._option():
                    self._token('hoarestate')
                with self._option():
                    self._token('tycondef')
                with self._option():
                    self._token('synth_definition')
                self._error('expecting one of: ML_export SML_export SML_import abbreviation adhoc_overloading alias applicative approximate atom_decl attribute_setup axiomatization bnf bnf_axiomatization case_of_simps circus_process codatatype code_datatype code_identifier code_lazy_type code_monad code_pred code_printing code_reflect code_reserved code_thms coinductive coinductive_set compile_generated_files concrete_definition consts copy_bnf corec corecursive datatype datatype_compat datatype_record declaration declare declassify default_sort derive export_code external_file extract_type find_consts find_theorems fixrec free_constructors friend_of_corec fun_cases functor generate_file global_interpretation ground_function hide_class hide_const hide_fact hide_type hoarestate inductive inductive_cases inductive_set inductive_simps instance interpretation inv_definition judgment lemmas lemmas_with lift_bnf lift_definition lifting_forget lifting_update local_setup locset_definition memoize_correct memoize_fun method method_setup named_simpset named_theorems_rev nitpick_params no_adhoc_overloading no_notation no_syntax no_translations no_type_notation nominal_datatype nominal_function nominal_inductive nominal_primrec nominal_termination nonterminal notation old_rep_datatype oracle parametric_constant parse_ast_translation parse_translation partial_function preference_profile prepare_code_thms primcorec primcorecursive print_applicative print_ast_translation print_interps print_locale print_statement print_test print_theorems print_translation procedure_spec procedures program_spec quickcheck_generator quickcheck_params quotient_type real_expansion real_limit realizability realizers record recursive_spec refute_params schematic_goal sepref_decl_impl sepref_decl_intf sepref_decl_op sepref_definition sepref_register sepref_thm setup setup_lifting simproc_setup simps_of_case sledgehammer_params specification syntax syntax_declaration synth_definition term text_raw thm thy_deps translations tycondef typ type type_alias type_notation type_synonym typed_print_translation typedecl typedef unbundle value values')
        self.name_last_node('key')

        def block4():
            with self._group():
                with self._choice():
                    with self._option():
                        self._long_name_()
                    with self._option():
                        self._term_var_()
                    with self._option():
                        self._token(',')
                    with self._option():
                        self._token(';')
                    with self._option():
                        self._token('!')
                    with self._option():
                        self._token('if')
                    with self._option():
                        self._token('in')
                    with self._option():
                        self._token('=>')
                    with self._option():
                        self._token('<=')
                    with self._option():
                        self._token('<')
                    with self._option():
                        self._token('>')
                    with self._option():
                        self._token('file')
                    with self._option():
                        self._token('defines')
                    with self._option():
                        self._token('assumes')
                    with self._option():
                        self._token('and')
                    with self._option():
                        self._token('where')
                    with self._option():
                        self._token('::')
                    with self._option():
                        self._token('==')
                    with self._option():
                        self._token('=')
                    with self._option():
                        self._token('constant')
                    with self._option():
                        self._token('type_class')
                    with self._option():
                        self._token('|')
                    with self._option():
                        self._token('type_constructor')
                    with self._option():
                        self._token('class_instance')
                    with self._option():
                        self._token('-')
                    with self._option():
                        self._token('code_module')
                    with self._option():
                        self._token('for')
                    with self._option():
                        self._token('morphisms')
                    with self._option():
                        self._token('/')
                    with self._option():
                        self._token(':')
                    with self._option():
                        self._token('is')
                    with self._option():
                        self._token('?')
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('datatypes')
                    with self._option():
                        self._token('functions')
                    with self._option():
                        self._token('rewrites')
                    with self._option():
                        self._token('checking')
                    with self._option():
                        self._token('file_prefix')
                    with self._option():
                        self._token('module_name')
                    with self._option():
                        self._token('external_files')
                    with self._option():
                        self._token('export_files')
                    with self._option():
                        self._token('export_prefix')
                    with self._option():
                        self._content_bracket_()
                    with self._option():
                        self._content_square_bracket_()
                    with self._option():
                        self._content_open_closed_()
                    with self._option():
                        self._type_ident_()
                    self._error('expecting one of: ! + , - / : :: ; < <= = == => > ? and assumes checking class_instance code_module constant content_bracket content_open_closed content_square_bracket datatypes defines export_files export_prefix external_files file file_prefix for functions if in is long_name module_name morphisms rewrites term_var type_class type_constructor type_ident where |')
        self._closure(block4)
        self.name_last_node('args')
        with self._optional():
            self._proof_block_()
        self.name_last_node('proof')
        self.ast._define(
            ['args', 'key', 'proof', 'qualifier'],
            []
        )

    @tatsumasu('Sublocale')
    def _sublocale_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('sublocale')
                with self._option():
                    self._token('subclass')
                self._error('expecting one of: subclass sublocale')
        self.name_last_node('key')

        def block3():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('for')
                    with self._option():
                        self._token('where')
                    with self._option():
                        self._token('rewrites')
                    with self._option():
                        self._token('defines')
                    with self._option():
                        self._token('and')
                    with self._option():
                        self._token('==')
                    with self._option():
                        self._token('=')
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('<')
                    with self._option():
                        self._token('?')
                    with self._option():
                        self._token('::')
                    with self._option():
                        self._token(':')
                    with self._option():
                        self._content_open_closed_()
                    with self._option():
                        self._content_bracket_()
                    with self._option():
                        self._content_square_bracket_()
                    with self._option():
                        self._int_str_()
                    with self._option():
                        self._long_name_()
                    with self._option():
                        self._type_ident_()
                    self._error('expecting one of: + : :: < = == ? and content_bracket content_open_closed content_square_bracket defines for int_str long_name rewrites type_ident where')
        self._positive_closure(block3)
        self.name_last_node('sub_args')
        self._proof_block_()
        self.name_last_node('proof')
        self.ast._define(
            ['key', 'proof', 'sub_args'],
            []
        )

    @tatsumasu('Theorem')
    def _theorem_(self):  # noqa
        with self._optional():
            self._quanlifier_()
        self.name_last_node('qualifier')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('lemma')
                with self._option():
                    self._token('theorem')
                with self._option():
                    self._token('corollary')
                with self._option():
                    self._token('proposition')
                with self._option():
                    self._token('schematic_goal')
                self._error('expecting one of: corollary lemma proposition schematic_goal theorem')
        self.name_last_node('key')
        with self._optional():
            self._content_bracket_()
        self.name_last_node('locale')
        with self._optional():
            with self._optional():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._long_name_()
                        with self._option():
                            self._content_double_quotation_()
                        self._error('expecting one of: content_double_quotation long_name')
            self.name_last_node('thm_name')
            with self._optional():
                self._content_square_bracket_()
            self._token(':')
        self.name_last_node('thm_name_args')
        self._theorem_statement_()
        self.name_last_node('thm_stat')
        self._proof_block_()
        self.name_last_node('proof')

        def block10():
            self._diag_statement_()
        self._closure(block10)
        self.name_last_node('diag_stats')
        self.ast._define(
            ['diag_stats', 'key', 'locale', 'proof', 'qualifier', 'thm_name', 'thm_name_args', 'thm_stat'],
            []
        )

    @tatsumasu('LocaleClass')
    def _locale_class_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('locale')
                with self._option():
                    self._token('class')
                self._error('expecting one of: class locale')
        self.name_last_node('key')
        self._long_name_()
        self.name_last_node('class_name')
        with self._optional():
            self._token('=')
        self.name_last_node('eq')

        def block5():
            with self._group():
                with self._choice():
                    with self._option():
                        self._long_name_()
                    with self._option():
                        self._token('==')
                    with self._option():
                        self._token('=')
                    with self._option():
                        self._token('?')
                    with self._option():
                        self._token('::')
                    with self._option():
                        self._token(':')
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('where')
                    with self._option():
                        self._token('and')
                    with self._option():
                        self._content_open_closed_()
                    with self._option():
                        with self._group():
                            self._token('for')
                            self._variables_()
                    self._error('expecting one of: + : :: = == ? and content_open_closed for long_name where')
        self._closure(block5)
        self.name_last_node('inherited_names')

        def block8():
            self._precondition_()
        self._closure(block8)
        self.name_last_node('prec_or_name')
        with self._optional():
            self._token('begin')

            def block10():
                self._theory_statement_()
            self._closure(block10)
            self._token('end')
        self.name_last_node('ex_thy_stats')
        self.ast._define(
            ['class_name', 'eq', 'ex_thy_stats', 'inherited_names', 'key', 'prec_or_name'],
            []
        )

    @tatsumasu('Context')
    def _context_(self):  # noqa
        self._token('context')
        with self._optional():
            with self._choice():
                with self._option():

                    def block1():
                        self._precondition_()
                    self._positive_closure(block1)
                with self._option():
                    self._long_name_()
                self._error('expecting one of: long_name precondition')
        self.name_last_node('prec_or_name')
        self._token('begin')

        def block4():
            self._theory_statement_()
        self._closure(block4)
        self.name_last_node('thy_stats')
        self._token('end')
        self.ast._define(
            ['prec_or_name', 'thy_stats'],
            []
        )

    @tatsumasu('NamedTheorems')
    def _named_theorems_(self):  # noqa
        with self._optional():
            self._quanlifier_()
        self.name_last_node('qualifier')
        self._token('named_theorems')
        with self._group():

            def sep2():
                self._token('and')

            def block2():
                self._long_name_()
                with self._optional():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._name_()
                            with self._option():
                                self._content_open_closed_()
                            self._error('expecting one of: content_open_closed name')
            self._positive_join(block2, sep2)
        self.name_last_node('cont')
        self.ast._define(
            ['cont', 'qualifier'],
            []
        )

    @tatsumasu('Definition')
    def _definition_(self):  # noqa
        with self._choice():
            with self._option():
                with self._optional():
                    self._quanlifier_()
                self.name_last_node('qualifier')
                self._token('definition')
                self.name_last_node('key')
                with self._optional():
                    self._content_bracket_()
                self.name_last_node('locale')
                self._variables_()
                self.name_last_node('vars')
                self._token('where')
                self._propositions_()
                self.name_last_node('props')
            with self._option():
                with self._optional():
                    self._quanlifier_()
                self.name_last_node('qualifier')
                self._token('definition')
                self.name_last_node('key')
                with self._optional():
                    self._content_bracket_()
                self.name_last_node('locale')
                self._propositions_()
                self.name_last_node('props')
            self._error('expecting one of: definition private qualified quanlifier')
        self.ast._define(
            ['key', 'locale', 'props', 'qualifier', 'vars'],
            []
        )

    @tatsumasu()
    def _quanlifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('qualified')
            with self._option():
                self._token('private')
            self._error('expecting one of: private qualified')

    @tatsumasu('Function')
    def _function_(self):  # noqa
        with self._optional():
            self._quanlifier_()
        self.name_last_node('qualifier')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('function')
                with self._option():
                    self._token('fun')
                with self._option():
                    self._token('primrec')
                self._error('expecting one of: fun function primrec')
        self.name_last_node('key')
        with self._optional():
            self._content_bracket_()
        self.name_last_node('locale')
        self._variables_()
        self.name_last_node('vars')
        self._token('where')
        with self._group():

            def sep6():
                self._token('|')

            def block6():
                self._propositions_()
            self._positive_join(block6, sep6)
        self.name_last_node('cont')
        with self._optional():
            self._proof_block_()
        self.name_last_node('proof')
        self.ast._define(
            ['cont', 'key', 'locale', 'proof', 'qualifier', 'vars'],
            []
        )

    @tatsumasu('Termination')
    def _termination_(self):  # noqa
        with self._optional():
            self._quanlifier_()
        self.name_last_node('qualifier')
        self._token('termination')
        self.name_last_node('key')
        with self._optional():
            self._content_bracket_()
        self.name_last_node('locale')
        with self._optional():
            self._name_()
        self.name_last_node('name')
        self._proof_block_()
        self.name_last_node('proof')
        self.ast._define(
            ['key', 'locale', 'name', 'proof', 'qualifier'],
            []
        )

    @tatsumasu('TheoremStatement')
    def _theorem_statement_(self):  # noqa
        with self._choice():
            with self._option():

                def block1():
                    self._precondition_()
                self._closure(block1)
                self.name_last_node('preconditions')
                self._token('shows')
                self.name_last_node('key')
                self._propositions_()
                self.name_last_node('props')

                def block5():
                    self._diag_statement_()
                self._closure(block5)
                self.name_last_node('diag_stats')
            with self._option():

                def block7():
                    self._precondition_()
                self._closure(block7)
                self.name_last_node('preconditions')
                self._token('obtains')
                self.name_last_node('key')
                with self._group():

                    def sep10():
                        self._token('|')

                    def block10():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    with self._optional():
                                        self._content_bracket_()
                                    self._variables_()
                                    self._token('where')
                                    self._propositions_()
                                with self._option():
                                    with self._optional():
                                        self._content_bracket_()
                                    self._propositions_()
                                self._error('expecting one of: content_bracket propositions variables')
                    self._positive_join(block10, sep10)
                self.name_last_node('ob_cont')

                def block13():
                    self._diag_statement_()
                self._closure(block13)
                self.name_last_node('diag_stats')
            with self._option():
                self._propositions_()
                self.name_last_node('props')

                def block16():
                    self._diag_statement_()
                self._closure(block16)
                self.name_last_node('diag_stats')
            self._error('expecting one of: : assumes constrains content_bracket content_open_closed content_square_bracket defines fixes includes is_pattern long_name notes obtains precondition propositions shows term_var')
        self.ast._define(
            ['diag_stats', 'key', 'ob_cont', 'preconditions', 'props'],
            []
        )

    @tatsumasu()
    def _precondition_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('assumes')
                        with self._option():
                            self._token('defines')
                        self._error('expecting one of: assumes defines')
                self._propositions_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('fixes')
                        with self._option():
                            self._token('constrains')
                        self._error('expecting one of: constrains fixes')
                self._variables_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('includes')
                        with self._option():
                            self._token('notes')
                        self._error('expecting one of: includes notes')

                def block3():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('and')
                            with self._option():
                                self._token('=')
                            with self._option():
                                self._content_square_bracket_()
                            with self._option():
                                self._content_bracket_()
                            with self._option():
                                self._content_square_bracket_()
                            with self._option():
                                self._long_name_()
                            self._error('expecting one of: = and content_bracket content_square_bracket long_name')
                self._positive_closure(block3)
            self._error('expecting one of: assumes constrains defines fixes includes notes')

    @tatsumasu()
    def _is_pattern_(self):  # noqa
        self._content_bracket_()

    @tatsumasu()
    def _mixfix_(self):  # noqa
        self._content_bracket_()

    @tatsumasu('ProofBlock')
    def _proof_block_(self):  # noqa
        with self._choice():
            with self._option():

                def block1():
                    self._diag_statement_()
                self._closure(block1)
                self.name_last_node('diag_stats_pre')

                def block3():
                    with self._choice():
                        with self._option():
                            self._refinement_step_()
                        with self._option():
                            self._ignored_diag_()
                        self._error('expecting one of: ignored_diag refinement_step')
                self._closure(block3)
                self.name_last_node('rsteps')
                self._proof_qed_()
                self.name_last_node('key')

                def block7():
                    self._diag_statement_()
                self._closure(block7)
                self.name_last_node('diag_stats_post')
            with self._option():

                def block9():
                    self._diag_statement_()
                self._closure(block9)
                self.name_last_node('diag_stats_pre')

                def block11():
                    with self._choice():
                        with self._option():
                            self._refinement_step_()
                        with self._option():
                            self._ignored_diag_()
                        self._error('expecting one of: ignored_diag refinement_step')
                self._closure(block11)
                self.name_last_node('rsteps')
                self._closing_step_()
                self.name_last_node('key')

                def block15():
                    self._diag_statement_()
                self._closure(block15)
                self.name_last_node('diag_stats_post')
            with self._option():

                def block17():
                    self._diag_statement_()
                self._closure(block17)
                self.name_last_node('diag_stats_pre')
                self._token('@phantom')
                self.name_last_node('key')

                def block20():
                    self._diag_statement_()
                self._closure(block20)
                self.name_last_node('diag_stats_post')
            self._error('expecting one of: . .. @phantom \\<proof> apply apply1 applyF applyS back by chapter check_derivation check_derivation_C closing_step defer diag_statement done focus ignored_diag including nitpick oops paragraph prefer print_cases proof proof_qed quickcheck record_all_facts record_facts refinement_step section solved sorry subgoal_block subsection subsubsection supply text thm txt unfolding using')
        self.ast._define(
            ['diag_stats_post', 'diag_stats_pre', 'key', 'rsteps'],
            []
        )

    @tatsumasu('ProofQed')
    def _proof_qed_(self):  # noqa
        self._token('proof')
        with self._optional():
            self._tactic_()
        self.name_last_node('main_tac')

        def block2():
            with self._choice():
                with self._option():
                    self._isar_statement_()
                with self._option():
                    self._ignored_diag_()
                self._error('expecting one of: ignored_diag isar_statement')
        self._closure(block2)
        self.name_last_node('isar_stats')
        self._token('qed')
        with self._optional():
            self._tactic_()
        self.name_last_node('closing_tac')
        self.ast._define(
            ['closing_tac', 'isar_stats', 'main_tac'],
            []
        )

    @tatsumasu('RefinementStep')
    def _refinement_step_(self):  # noqa
        with self._choice():
            with self._option():

                def block1():
                    self._diag_statement_()
                self._closure(block1)
                self.name_last_node('diag_stats_pre')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('using')
                        with self._option():
                            self._token('unfolding')
                        self._error('expecting one of: unfolding using')
                self.name_last_node('key')

                def block5():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('and')
                            with self._option():
                                self._double_square_bracket_()
                            with self._option():
                                self._fact_reference_()
                            self._error('expecting one of: and double_square_bracket fact_reference')
                self._positive_closure(block5)
                self.name_last_node('facts')
            with self._option():

                def block8():
                    self._diag_statement_()
                self._closure(block8)
                self.name_last_node('diag_stats_pre')
                self._token('including')
                self.name_last_node('key')

                def block11():
                    self._long_name_()
                self._positive_closure(block11)
                self.name_last_node('incl_args')
            with self._option():

                def block13():
                    self._diag_statement_()
                self._closure(block13)
                self.name_last_node('diag_stats_pre')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('apply')
                        with self._option():
                            self._token('applyS')
                        with self._option():
                            self._token('applyF')
                        with self._option():
                            self._token('apply1')
                        self._error('expecting one of: apply apply1 applyF applyS')
                self.name_last_node('key')
                self._tactic_()
                self.name_last_node('tac')
            with self._option():

                def block18():
                    self._diag_statement_()
                self._closure(block18)
                self.name_last_node('diag_stats_pre')
                with self._group():
                    self._token('focus')
                self.name_last_node('key')
                with self._optional():
                    self._tactic_()
                self.name_last_node('tac')
            with self._option():

                def block22():
                    self._diag_statement_()
                self._closure(block22)
                self.name_last_node('diag_stats_pre')
                self._token('supply')
                self.name_last_node('key')
                with self._group():

                    def sep25():
                        self._token('and')

                    def block25():
                        with self._optional():
                            with self._optional():
                                self._long_name_()
                            with self._optional():
                                self._content_square_bracket_()
                            self._token('=')

                        def block27():
                            with self._choice():
                                with self._option():
                                    self._double_square_bracket_()
                                with self._option():
                                    self._fact_reference_()
                                self._error('expecting one of: double_square_bracket fact_reference')
                        self._positive_closure(block27)
                        self.name_last_node('facts')
                    self._positive_join(block25, sep25)
                self.name_last_node('supply_args')
            with self._option():

                def block30():
                    self._diag_statement_()
                self._closure(block30)
                self.name_last_node('diag_stats_pre')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('defer')
                        with self._option():
                            self._token('prefer')
                        with self._option():
                            self._token('back')
                        with self._option():
                            self._token('solved')
                        self._error('expecting one of: back defer prefer solved')
                self.name_last_node('key')
                with self._optional():
                    self._integer_()
                self.name_last_node('tac_arg')
            with self._option():

                def block35():
                    self._diag_statement_()
                self._closure(block35)
                self.name_last_node('diag_stats_pre')
                self._subgoal_block_()
                self.name_last_node('sblock')
            self._error('expecting one of: apply apply1 applyF applyS back check_derivation check_derivation_C defer diag_statement focus including prefer record_all_facts record_facts solved subgoal subgoal_block supply unfolding using')
        self.ast._define(
            ['diag_stats_pre', 'facts', 'incl_args', 'key', 'sblock', 'supply_args', 'tac', 'tac_arg'],
            []
        )

    @tatsumasu('ClosingStep')
    def _closing_step_(self):  # noqa
        with self._choice():
            with self._option():

                def block1():
                    self._diag_statement_()
                self._closure(block1)
                self.name_last_node('diag_stats_pre')
                self._token('by')
                self.name_last_node('key')
                self._tactic_()
                self.name_last_node('main_tac')
                with self._optional():
                    self._tactic_()
                self.name_last_node('closing_tac')
            with self._option():

                def block6():
                    self._diag_statement_()
                self._closure(block6)
                self.name_last_node('diag_stats_pre')
                self._token('sorry')
                self.name_last_node('key')
            with self._option():

                def block9():
                    self._diag_statement_()
                self._closure(block9)
                self.name_last_node('diag_stats_pre')
                self._token('oops')
                self.name_last_node('key')
            with self._option():

                def block12():
                    self._diag_statement_()
                self._closure(block12)
                self.name_last_node('diag_stats_pre')
                self._token('done')
                self.name_last_node('key')
            with self._option():

                def block15():
                    self._diag_statement_()
                self._closure(block15)
                self.name_last_node('diag_stats_pre')
                self._token('\\<proof>')
                self.name_last_node('key')
            with self._option():

                def block18():
                    self._diag_statement_()
                self._closure(block18)
                self.name_last_node('diag_stats_pre')
                self._token('..')
                self.name_last_node('key')
            with self._option():

                def block21():
                    self._diag_statement_()
                self._closure(block21)
                self.name_last_node('diag_stats_pre')
                self._token('.')
                self.name_last_node('key')
            self._error('expecting one of: . .. \\<proof> by check_derivation check_derivation_C diag_statement done oops record_all_facts record_facts sorry')
        self.ast._define(
            ['closing_tac', 'diag_stats_pre', 'key', 'main_tac'],
            []
        )

    @tatsumasu('SubgoalBlock')
    def _subgoal_block_(self):  # noqa
        self._token('subgoal')
        with self._optional():
            self._long_name_()
        self.name_last_node('bname')
        with self._optional():
            self._token('premises')
            with self._optional():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._token('_')
                        self._error('expecting one of: _ name')
            self.name_last_node('prem_name')
            with self._optional():
                self._content_square_bracket_()
        self.name_last_node('prems')
        with self._optional():
            self._token('for')
            self._variables_()
        self.name_last_node('for_vars')
        self._proof_block_()
        self.name_last_node('proof')
        self.ast._define(
            ['bname', 'for_vars', 'prem_name', 'prems', 'proof'],
            []
        )

    @tatsumasu('IsarStatement')
    def _isar_statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('include')
                self.name_last_node('key')

                def block2():
                    self._long_name_()
                self._closure(block2)
                self.name_last_node('incl_args')
            with self._option():

                def block4():
                    self._diag_statement_()
                self._closure(block4)
                self.name_last_node('diag_stats_pre1')
                with self._optional():
                    self._pre_facts_()
                self.name_last_node('pre_facts')

                def block7():
                    self._diag_statement_()
                self._closure(block7)
                self.name_last_node('diag_stats_pre2')
                self._token('consider')
                self.name_last_node('key')

                def block10():
                    with self._choice():
                        with self._option():
                            self._token('and')
                        with self._option():
                            self._token('::')
                        with self._option():
                            self._token('|')
                        with self._option():
                            self._token('where')
                        with self._option():
                            self._type_ident_()
                        with self._option():
                            self._term_()
                        with self._option():
                            self._content_bracket_()
                        self._error('expecting one of: :: and content_bracket term type_ident where |')
                self._positive_closure(block10)
                self.name_last_node('consider_args')
                self._proof_block_()
                self.name_last_node('proof')
            with self._option():

                def block14():
                    self._diag_statement_()
                self._closure(block14)
                self.name_last_node('diag_stats_pre1')
                with self._optional():
                    self._pre_facts_()
                self.name_last_node('pre_facts')

                def block17():
                    self._diag_statement_()
                self._closure(block17)
                self.name_last_node('diag_stats_pre2')
                self._token('guess')
                self.name_last_node('key')
                self._variables_()
                self.name_last_node('vars')
                self._proof_block_()
                self.name_last_node('proof')
            with self._option():
                with self._optional():
                    self._pre_facts_()
                self.name_last_node('pre_facts')
                self._token('{')
                self.name_last_node('key')

                def block24():
                    with self._choice():
                        with self._option():
                            self._isar_statement_()
                        with self._option():
                            self._ignored_diag_()
                        self._error('expecting one of: ignored_diag isar_statement')
                self._closure(block24)
                self.name_last_node('isar_stats')
                self._token('}')

                def block27():
                    self._diag_statement_()
                self._closure(block27)
                self.name_last_node('diag_stats_post')
            with self._option():
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('moreover')
                        with self._option():
                            self._token('also')
                        self._error('expecting one of: also moreover')
                self.name_last_node('pre_facts')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('assume')
                        with self._option():
                            self._token('presume')
                        self._error('expecting one of: assume presume')
                self.name_last_node('key')
                self._propositions_()
                self.name_last_node('props')

                def block34():
                    self._diag_statement_()
                self._closure(block34)
                self.name_last_node('diag_stats_post')
            with self._option():
                with self._optional():
                    self._token('moreover')
                self.name_last_node('pre_facts')
                self._token('case')
                self.name_last_node('key')
                with self._optional():
                    with self._optional():
                        self._long_name_()
                    with self._optional():
                        self._content_square_bracket_()
                    self._token(':')
                self.name_last_node('case_name')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._int_str_()
                        with self._option():
                            self._name_()
                        with self._option():
                            self._content_bracket_()
                        with self._option():
                            self._content_open_closed_()
                        self._error('expecting one of: content_bracket content_open_closed int_str name')
                self.name_last_node('case_arg')

                def block41():
                    self._diag_statement_()
                self._closure(block41)
                self.name_last_node('diag_stats_post')
            with self._option():
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('moreover')
                        with self._option():
                            self._token('also')
                        self._error('expecting one of: also moreover')
                self.name_last_node('pre_facts')
                self._token('define')
                self.name_last_node('key')
                self._variables_()
                self.name_last_node('vars')
                self._token('where')
                self._propositions_()
                self.name_last_node('props')

                def block48():
                    self._diag_statement_()
                self._closure(block48)
                self.name_last_node('diag_stats_post')
            with self._option():

                def block50():
                    self._diag_statement_()
                self._closure(block50)
                self.name_last_node('diag_stats_pre1')
                self._pre_facts_()
                self.name_last_node('pre_facts')

                def block53():
                    self._diag_statement_()
                self._closure(block53)
                self.name_last_node('diag_stats_pre2')
                self._token('interpret')
                self.name_last_node('key')

                def block56():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('rewrites')
                            with self._option():
                                self._token('and')
                            with self._option():
                                self._token('where')
                            with self._option():
                                self._long_name_()
                            with self._option():
                                self._term_var_()
                            with self._option():
                                self._token('?')
                            with self._option():
                                self._token(':')
                            with self._option():
                                self._token('+')
                            with self._option():
                                self._token('=')
                            with self._option():
                                self._content_open_closed_()
                            self._error('expecting one of: + : = ? and content_open_closed long_name rewrites term_var where')
                self._positive_closure(block56)
                self.name_last_node('inter_args')
                with self._optional():
                    self._token('for')
                    self._variables_()
                self.name_last_node('for_vars')
                self._proof_block_()
                self.name_last_node('proof')
            with self._option():

                def block61():
                    self._diag_statement_()
                self._closure(block61)
                self.name_last_node('diag_stats_pre1')
                self._pre_facts_()
                self.name_last_node('pre_facts')

                def block64():
                    self._diag_statement_()
                self._closure(block64)
                self.name_last_node('diag_stats_pre2')
                self._token('note')
                self.name_last_node('key')
                with self._group():

                    def sep67():
                        self._token('and')

                    def block67():
                        with self._optional():
                            with self._optional():
                                self._long_name_()
                            with self._optional():
                                self._content_square_bracket_()
                            self._token('=')

                        def block69():
                            with self._choice():
                                with self._option():
                                    self._double_square_bracket_()
                                with self._option():
                                    self._fact_reference_()
                                self._error('expecting one of: double_square_bracket fact_reference')
                        self._positive_closure(block69)
                        self.name_last_node('facts')
                    self._positive_join(block67, sep67)
                self.name_last_node('name_eq')

                def block71():
                    self._diag_statement_()
                self._closure(block71)
                with self._group():
                    with self._choice():
                        with self._option():
                            self._proof_block_()
                        with self._option():
                            self._constant('@phantom')
                        self._error('expecting one of: proof_block')
                self.name_last_node('proof')
            with self._option():

                def block75():
                    self._diag_statement_()
                self._closure(block75)
                self.name_last_node('diag_stats_pre1')
                self._pre_facts_()
                self.name_last_node('pre_facts')

                def block78():
                    self._diag_statement_()
                self._closure(block78)
                self.name_last_node('diag_stats_pre2')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('have')
                        with self._option():
                            self._token('show')
                        with self._option():
                            self._token('hence')
                        with self._option():
                            self._token('thus')
                        self._error('expecting one of: have hence show thus')
                self.name_last_node('key')
                self._propositions_()
                self.name_last_node('props')
                with self._optional():
                    self._token('when')
                    self._propositions_()
                self.name_last_node('when_if')
                with self._optional():
                    self._token('for')
                    self._variables_()
                self.name_last_node('for_vars')
                self._proof_block_()
                self.name_last_node('proof')
            with self._option():

                def block86():
                    self._diag_statement_()
                self._closure(block86)
                self.name_last_node('diag_stats_pre1')
                self._pre_facts_()
                self.name_last_node('pre_facts')

                def block89():
                    self._diag_statement_()
                self._closure(block89)
                self.name_last_node('diag_stats_pre2')
                self._token('obtain')
                self.name_last_node('key')
                with self._optional():
                    self._variables_()
                    self.name_last_node('vars')
                    self._token('where')
                self._propositions_()
                self.name_last_node('props')
                self._proof_block_()
                self.name_last_node('proof')
            with self._option():
                self._pre_facts_()
                self.name_last_node('pre_facts')
                self._token('fix')
                self.name_last_node('key')
                self._variables_()
                self.name_last_node('vars')

                def block98():
                    self._diag_statement_()
                self._closure(block98)
                self.name_last_node('diag_stats_post')
            with self._option():
                self._pre_facts_()
                self.name_last_node('pre_facts')
                self._token('let')
                self.name_last_node('key')
                self._instantiations_()
                self.name_last_node('inst')

                def block103():
                    self._diag_statement_()
                self._closure(block103)
                self.name_last_node('diag_stats_post')
            with self._option():
                self._token('write')
                self.name_last_node('key')

                def block106():
                    with self._choice():
                        with self._option():
                            self._token('and')
                        with self._option():
                            self._long_name_()
                        with self._option():
                            self._content_bracket_()
                        self._error('expecting one of: and content_bracket long_name')
                self._positive_closure(block106)
                self.name_last_node('write_args')

                def block109():
                    self._diag_statement_()
                self._closure(block109)
                self.name_last_node('diag_stats_post')
            with self._option():
                self._token('next')
                self.name_last_node('key')

                def block112():
                    self._diag_statement_()
                self._closure(block112)
                self.name_last_node('diag_stats_post')
            self._error('expecting one of: also and assume case check_derivation check_derivation_C consider content_bracket define diag_statement fact_reference finally fix from guess have hence include interpret let moreover next note obtain pre_facts presume record_all_facts record_facts show then thus ultimately with write {')
        self.ast._define(
            ['case_arg', 'case_name', 'consider_args', 'diag_stats_post', 'diag_stats_pre1', 'diag_stats_pre2', 'facts', 'for_vars', 'incl_args', 'inst', 'inter_args', 'isar_stats', 'key', 'name_eq', 'pre_facts', 'proof', 'props', 'vars', 'when_if', 'write_args'],
            []
        )

    @tatsumasu()
    def _pre_facts_(self):  # noqa

        def block0():
            with self._choice():
                with self._option():
                    self._fact_reference_()
                with self._option():
                    self._content_bracket_()
                with self._option():
                    self._token('moreover')
                with self._option():
                    self._token('also')
                with self._option():
                    self._token('with')
                with self._option():
                    self._token('from')
                with self._option():
                    self._token('then')
                with self._option():
                    self._token('finally')
                with self._option():
                    self._token('ultimately')
                with self._option():
                    self._token('and')
                self._error('expecting one of: /\\((\\\\<open>(.|\\n)*?\\\\<close>|"(.|\\n)*?(?<!\\\\)"|(?!(\\(|\\)))(.|\\n)|(?R))*\\)/ also and back_quote cartouche content_bracket fact_reference finally from long_name moreover then ultimately with')
        self._closure(block0)

    @tatsumasu('Tactic')
    def _tactic_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('-')
                self.name_last_node('key')
            with self._option():
                self._token('(')
                self.name_last_node('key')
                self._single_tactic_()
                self.name_last_node('main_tactic')

                def block4():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token(',')
                            with self._option():
                                self._token(';')
                            with self._option():
                                self._token('|')
                            self._error('expecting one of: , ; |')
                    self._single_tactic_()
                self._closure(block4)
                self.name_last_node('more_tactics')
                self._token(')')
                with self._optional():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('+')
                            with self._option():
                                self._token('?')
                            with self._option():
                                self._content_square_bracket_()
                            self._error('expecting one of: + ? content_square_bracket')
                self.name_last_node('tac_mod')
            with self._option():
                self._name_()
                self.name_last_node('key')
                with self._optional():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('+')
                            with self._option():
                                self._token('?')
                            with self._option():
                                self._content_square_bracket_()
                            self._error('expecting one of: + ? content_square_bracket')
                self.name_last_node('tac_mod')
            self._error("expecting one of: ( - /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ name")
        self.ast._define(
            ['key', 'main_tactic', 'more_tactics', 'tac_mod'],
            []
        )

    @tatsumasu()
    def _single_tactic_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('sos')
                self.name_last_node('key')

                def block2():
                    self._term_()
                self._closure(block2)
                self.name_last_node('sos_args')
            with self._option():
                self._token('vcg')
                self.name_last_node('key')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('add')
                            self._token(':')

                            def block6():
                                self._fact_reference_()
                            self._closure(block6)
                            self.name_last_node('facts')
                        with self._option():
                            self._name_()
                            self._token('=')
                            self._name_()
                        self._error('expecting one of: add name')
                self.name_last_node('vcg_args')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('has_type_tac')
                        with self._option():
                            self._token("has_type_tac'")
                        with self._option():
                            self._token('has_type_no_if_tac')
                        with self._option():
                            self._token('if_type_tac')
                        self._error("expecting one of: has_type_no_if_tac has_type_tac has_type_tac' if_type_tac")
                self.name_last_node('key')

                def block11():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('prog')
                            with self._option():
                                self._token('aexpr')
                            with self._option():
                                self._token('bexpr')
                            with self._option():
                                self._token('custom_if')
                            self._error('expecting one of: aexpr bexpr custom_if prog')
                    self._token(':')

                    def block14():
                        with self._ifnot():
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._token('prog')
                                    with self._option():
                                        self._token('aexpr')
                                    with self._option():
                                        self._token('bexpr')
                                    with self._option():
                                        self._token('custom_if')
                                    self._error('expecting one of: aexpr bexpr custom_if prog')
                        self._fact_reference_()
                    self._positive_closure(block14)
                    self.name_last_node('facts')
                self._closure(block11)
                self.name_last_node('tac_args')
            with self._option():
                self._token('PLM_solver')
                self.name_last_node('key')
                with self._optional():
                    self._token('PLM_intro')
                    self._token(':')

                    def block19():
                        self._fact_reference_()
                    self._closure(block19)
                    self.name_last_node('facts')
                self.name_last_node('tac_args')
            with self._option():
                self._token('autoref')
                self.name_last_node('key')

                def block22():
                    with self._choice():
                        with self._option():
                            self._content_bracket_()
                        with self._option():
                            self._token('phases')
                            self._token(':')

                            def block23():
                                self._name_()
                            self._closure(block23)
                        self._error('expecting one of: content_bracket phases')
                self._closure(block22)
                self.name_last_node('autoref_args')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('seq_decl_inv_method')
                        with self._option():
                            self._token('seq_stop_inv_method')
                        self._error('expecting one of: seq_decl_inv_method seq_stop_inv_method')
                self.name_last_node('key')

                def block28():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('inv_rule')
                            with self._option():
                                self._token('rel_inv_rule')
                            self._error('expecting one of: inv_rule rel_inv_rule')
                    self._token(':')

                    def block31():
                        with self._ifnot():
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._token('inv_rule')
                                    with self._option():
                                        self._token('rel_inv_rule')
                                    self._error('expecting one of: inv_rule rel_inv_rule')
                        self._fact_reference_()
                    self._positive_closure(block31)
                    self.name_last_node('facts')
                self._closure(block28)
                self.name_last_node('tac_args')
            with self._option():
                self._token('sep_auto')
                self.name_last_node('key')

                def block35():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._content_bracket_()
                            with self._option():
                                self._content_square_bracket_()
                            self._error('expecting one of: content_bracket content_square_bracket')
                self._closure(block35)
                self.name_last_node('method_opt')

                def block38():
                    with self._group():
                        self._tactic_modifier_()
                    self._token(':')

                    def block40():
                        with self._ifnot():
                            with self._group():
                                self._tactic_modifier_()
                        self._fact_reference_()
                    self._positive_closure(block40)
                    self.name_last_node('facts')
                self._closure(block38)
                self.name_last_node('tac_args')
            with self._option():
                self._token('r_compose')
                self.name_last_node('key')

                def block43():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('r1')
                            with self._option():
                                self._token('r2')
                            with self._option():
                                self._token('r3')
                            self._error('expecting one of: r1 r2 r3')
                    self._token(':')
                    self._fact_reference_()
                    self.name_last_node('facts')
                self._closure(block43)
                self.name_last_node('r_compose_args')
            with self._option():
                self._token('master_theorem')
                self.name_last_node('key')

                def block48():
                    with self._choice():
                        with self._option():
                            self._token('recursion')
                            self._token(':')
                            self._fact_reference_()
                            self.name_last_node('facts')
                        with self._option():
                            self._token("p'")
                            self._token(':')
                            self._rat_str_()
                        with self._option():
                            self._rat_str_()
                        self._error("expecting one of: p' rat_str recursion")
                self._closure(block48)
                self.name_last_node('master_args')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token("transfer'")
                        with self._option():
                            self._token('transfer')
                        self._error("expecting one of: transfer transfer'")
                self.name_last_node('key')

                def block54():
                    with self._group():
                        with self._ifnot():
                            self._token('fixing')
                    self._fact_reference_()
                self._closure(block54)
                self.name_last_node('facts')
                with self._optional():
                    self._token('fixing')
                    self._token(':')

                    def block56():
                        self._term_()
                    self._closure(block56)
                self.name_last_node('transfer_opt')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('frpar')
                        with self._option():
                            self._token('frpar2')
                        self._error('expecting one of: frpar frpar2')
                self.name_last_node('key')

                def block60():
                    with self._choice():
                        with self._option():
                            self._token('type')
                            self._token(':')
                        with self._option():
                            self._token('pars')
                            self._token(':')
                        with self._option():
                            self._type_ident_()
                        with self._option():
                            self._term_()
                        self._error('expecting one of: pars term type type_ident')
                self._closure(block60)
                self.name_last_node('frpar_args')
            with self._option():
                with self._group():
                    self._token('approximation')
                self.name_last_node('key')

                def block64():
                    with self._choice():
                        with self._option():
                            self._token('splitting')
                            self._token(':')
                        with self._option():
                            self._token('taylor')
                            self._token(':')
                        with self._option():
                            self._token('=')
                        with self._option():
                            self._term_()
                        self._error('expecting one of: = splitting taylor term')
                self._closure(block64)
                self.name_last_node('approx_args')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('cases')
                        with self._option():
                            self._token('relation')
                        with self._option():
                            self._token('case_tac')
                        with self._option():
                            self._token('injectivity_solver')
                        with self._option():
                            self._token('transfer_hma')
                        with self._option():
                            self._token('inst_existentials')
                        self._error('expecting one of: case_tac cases injectivity_solver inst_existentials relation transfer_hma')
                self.name_last_node('key')

                def block69():
                    with self._choice():
                        with self._option():
                            self._content_square_bracket_()
                        with self._option():
                            self._content_bracket_()
                        self._error('expecting one of: content_bracket content_square_bracket')
                self._closure(block69)
                self.name_last_node('tac_opt')

                def block72():
                    with self._ifnot():
                        with self._group():
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._token('rule')
                                    with self._option():
                                        self._token('set')
                                    with self._option():
                                        self._token('type')
                                    with self._option():
                                        self._token('pred')
                                    self._error('expecting one of: pred rule set type')
                            self._token(':')
                    self._term_()
                self._closure(block72)
                self.name_last_node('cases_trm')
                with self._optional():
                    self._token('for')
                    self._variables_()
                self.name_last_node('for_vars')

                def block76():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('set')
                            with self._option():
                                self._token('type')
                            with self._option():
                                self._token('pred')
                            self._error('expecting one of: pred set type')
                    self._token(':')
                    self._term_()
                self._closure(block76)
                self.name_last_node('set_part')
                with self._optional():
                    self._token('rule')
                    self._token(':')
                    self._fact_reference_()
                self.name_last_node('rule_fact')
            with self._option():
                self._token('rewrite')
                self.name_last_node('key')

                def block81():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('in')
                            with self._option():
                                self._token('at')
                            with self._option():
                                self._token('to')
                            self._error('expecting one of: at in to')
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._term_()
                            with self._option():
                                self._token('for')
                                self._content_bracket_()
                            self._error('expecting one of: for term')
                self._closure(block81)
                self.name_last_node('rewrite_args')
                self._fact_reference_()
                self.name_last_node('fact')
            with self._option():
                self._token('subst')
                self.name_last_node('key')

                def block87():
                    self._content_bracket_()
                self._closure(block87)
                self.name_last_node('subst_opt')

                def block89():
                    self._fact_reference_()
                self._positive_closure(block89)
                self.name_last_node('facts')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('rule_tac')
                        with self._option():
                            self._token('drule_tac')
                        with self._option():
                            self._token('erule_tac')
                        with self._option():
                            self._token('frule_tac')
                        with self._option():
                            self._token('cut_tac')
                        with self._option():
                            self._token('subst_tac')
                        with self._option():
                            self._token('hoare_rule')
                        self._error('expecting one of: cut_tac drule_tac erule_tac frule_tac hoare_rule rule_tac subst_tac')
                self.name_last_node('key')

                def block93():
                    self._content_square_bracket_()
                self._closure(block93)
                self.name_last_node('tac_opt')
                with self._optional():
                    self._instantiations_()
                    self._token('in')
                self.name_last_node('inst')

                def block96():
                    self._fact_reference_()
                self._positive_closure(block96)
                self.name_last_node('facts')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('rename_tac')
                        with self._option():
                            self._token('tactic')
                        with self._option():
                            self._token('subgoal_tac')
                        with self._option():
                            self._token('thin_tac')
                        with self._option():
                            self._token('ind_cases')
                        with self._option():
                            self._token('rotate_tac')
                        self._error('expecting one of: ind_cases rename_tac rotate_tac subgoal_tac tactic thin_tac')
                self.name_last_node('key')

                def block100():
                    self._content_square_bracket_()
                self._closure(block100)
                self.name_last_node('tac_opt')

                def block102():
                    self._term_()
                self._positive_closure(block102)
                self.name_last_node('rename_trm')
                with self._optional():
                    self._token('for')
                    self._variables_()
                self.name_last_node('for_vars')
            with self._option():
                self._token('use')
                self.name_last_node('key')

                def block106():
                    with self._group():
                        with self._ifnot():
                            self._token('in')
                    self._fact_reference_()
                self._positive_closure(block106)
                self.name_last_node('facts')
                self._token('in')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._token('\\<open>')

                            def sep108():
                                with self._group():
                                    with self._choice():
                                        with self._option():
                                            self._token(',')
                                        with self._option():
                                            self._token(';')
                                        with self._option():
                                            self._token('|')
                                        self._error('expecting one of: , ; |')

                            def block108():
                                self._single_tactic_()
                            self._positive_join(block108, sep108)
                            self._token('\\<close>')
                        self._error('expecting one of: \\<open> name')
                self.name_last_node('more_tac')
            with self._option():
                self._token('all')
                self.name_last_node('key')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._token('\\<open>')

                            def sep113():
                                with self._group():
                                    with self._choice():
                                        with self._option():
                                            self._token(',')
                                        with self._option():
                                            self._token(';')
                                        with self._option():
                                            self._token('|')
                                        self._error('expecting one of: , ; |')

                            def block113():
                                self._single_tactic_()
                            self._positive_join(block113, sep113)
                            self._token('\\<close>')
                        self._error('expecting one of: \\<open> name')
                self.name_last_node('more_tac')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('induct_tac')
                        with self._option():
                            self._token('induction')
                        with self._option():
                            self._token('induct')
                        with self._option():
                            self._token('coinduct')
                        with self._option():
                            self._token('coinduction')
                        with self._option():
                            self._token('nominal_induct')
                        self._error('expecting one of: coinduct coinduction induct induct_tac induction nominal_induct')
                self.name_last_node('key')

                def block119():
                    with self._group():
                        with self._ifnot():
                            self._induct_modifier_()
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._term_()
                            with self._option():
                                self._token('(')
                                self._term_()
                                self._token(')')
                            with self._option():
                                self._token('\\<equiv>')
                            with self._option():
                                self._token('==')
                            with self._option():
                                self._token('and')
                            with self._option():
                                self._content_square_bracket_()
                            self._error('expecting one of: ( == \\<equiv> and content_square_bracket term')
                self._closure(block119)
                self.name_last_node('induct_trm')

                def block122():
                    with self._ifnot():
                        with self._group():
                            self._token('rule')
                    self._induct_modifier_()
                    self._token(':')

                    def block123():
                        with self._group():
                            with self._ifnot():
                                with self._group():
                                    self._induct_modifier_()
                                    self._token(':')
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('and')
                                with self._option():
                                    self._term_()
                                self._error('expecting one of: and term')
                    self._closure(block123)
                self._closure(block122)
                self.name_last_node('induct_arb')
                with self._optional():
                    self._token('rule')
                    self._token(':')

                    def block126():
                        self._fact_reference_()
                    self._positive_closure(block126)
                self.name_last_node('induct_rule')
            with self._option():
                self._name_()
                self.name_last_node('method_name')
                with self._ifnot():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('+')
                            with self._option():
                                self._token('?')
                            self._error('expecting one of: + ?')

                def block130():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._content_bracket_()
                            with self._option():
                                self._content_square_bracket_()
                            self._error('expecting one of: content_bracket content_square_bracket')
                self._closure(block130)
                self.name_last_node('method_opt')

                def block133():
                    with self._optional():
                        self._tactic_modifier_()
                        self._token(':')

                    def block135():
                        with self._ifnot():
                            with self._group():
                                self._tactic_modifier_()
                                self._token(':')
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._fact_reference_()
                                with self._option():
                                    self._content_bracket_()
                                with self._option():
                                    self._content_square_bracket_()
                                self._error('expecting one of: content_bracket content_square_bracket fact_reference')
                    self._closure(block135)
                    self.name_last_node('facts')
                self._positive_closure(block133)
                self.name_last_node('attributed_facts')
            with self._option():
                self._tactic_()
                self.name_last_node('key')
            self._error("expecting one of: ( - /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ PLM_solver all approximation autoref case_tac cases coinduct coinduction cut_tac drule_tac erule_tac frpar frpar2 frule_tac has_type_no_if_tac has_type_tac has_type_tac' hoare_rule if_type_tac ind_cases induct induct_tac induction injectivity_solver inst_existentials master_theorem name nominal_induct r_compose relation rename_tac rewrite rotate_tac rule_tac sep_auto seq_decl_inv_method seq_stop_inv_method sos subgoal_tac subst subst_tac tactic thin_tac transfer transfer' transfer_hma use vcg")
        self.ast._define(
            ['approx_args', 'attributed_facts', 'autoref_args', 'cases_trm', 'fact', 'facts', 'for_vars', 'frpar_args', 'induct_arb', 'induct_rule', 'induct_trm', 'inst', 'key', 'master_args', 'method_name', 'method_opt', 'more_tac', 'r_compose_args', 'rename_trm', 'rewrite_args', 'rule_fact', 'set_part', 'sos_args', 'subst_opt', 'tac_args', 'tac_opt', 'transfer_opt', 'vcg_args'],
            []
        )

    @tatsumasu()
    def _term_(self):  # noqa
        with self._choice():
            with self._option():
                self._term_var_()
            with self._option():
                self._long_name_()
            with self._option():
                self._int_str_()
            with self._option():
                self._content_open_closed_()
            self._error('expecting one of: /"(.|\\n)*?(?<!\\\\)"/ /((?P>name)\\.)+(?P<name>([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>))/ /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /(\\\\<open>)((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?R))*(\\\\<close>)/ /-?( )*[0-9]+/ /[\\*_#&$]+/ /\\?([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)(\\.[0-9]+)?/ /\\\\<([A-Za-z][A-Za-z0-9_\']*)>/ /\\{\\*(.|\\n)*?\\*\\}/ content_double_quotation content_open_closed int_str long_name name term_var')

    @tatsumasu('Instantiations')
    def _instantiations_(self):  # noqa
        self._instantiation_()
        self.name_last_node('main_inst')

        def block2():
            self._token('and')
            self._instantiation_()
        self._closure(block2)
        self.name_last_node('more_insts')
        self.ast._define(
            ['main_inst', 'more_insts'],
            []
        )

    @tatsumasu()
    def _instantiation_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._name_()
                with self._option():
                    self._type_ident_()
                with self._option():
                    self._term_var_()
                with self._option():
                    self._type_var_()
                with self._option():
                    self._content_open_closed_()
                self._error('expecting one of: content_open_closed name term_var type_ident type_var')
        self.name_last_node('left')
        self._token('=')
        with self._group():
            with self._choice():
                with self._option():
                    self._long_name_()
                with self._option():
                    self._term_var_()
                with self._option():
                    self._type_ident_()
                with self._option():
                    self._content_open_closed_()
                self._error('expecting one of: content_open_closed long_name term_var type_ident')
        self.name_last_node('right')
        with self._optional():
            self._token('for')
            self._variables_()
        self.name_last_node('for_vars')
        self.ast._define(
            ['for_vars', 'left', 'right'],
            []
        )

    @tatsumasu()
    def _induct_modifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('rule')
            with self._option():
                self._token('arbitrary')
            with self._option():
                self._token('set')
            with self._option():
                self._token('pred')
            with self._option():
                self._token('taking')
            with self._option():
                self._token('avoiding')
            with self._option():
                self._token('type')
            self._error('expecting one of: arbitrary avoiding pred rule set taking type')

    @tatsumasu()
    def _tactic_modifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('add')
            with self._option():
                self._token('simp')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('add')
                        with self._option():
                            self._token('del')
                        with self._option():
                            self._token('flip')
                        with self._option():
                            self._token('only')
                        self._error('expecting one of: add del flip only')
            with self._option():
                self._token('del')
            with self._option():
                self._token('dest')
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('intro')
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('elim')
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('flip')
            with self._option():
                self._token('only')
            with self._option():
                self._token('split')
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('cong')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('add')
                        with self._option():
                            self._token('del')
                        self._error('expecting one of: add del')
            with self._option():
                self._token('iff')
            with self._option():
                self._token('eintros')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('add')
                        with self._option():
                            self._token('del')
                        self._error('expecting one of: add del')
            with self._option():
                self._token('dflt_simps')
            with self._option():
                self._token('heap')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token('add')
                        with self._option():
                            self._token('del')
                        self._error('expecting one of: add del')
            with self._option():
                self._token('inv')
                self._token('add')
            with self._option():
                self._token('solve')
            with self._option():
                self._token('rec')
            with self._option():
                self._token('decon')
            with self._option():
                self._token('fresh')
            self._error('expecting one of: add cong decon del dest dflt_simps eintros elim flip fresh heap iff intro inv only rec simp solve split')

    @tatsumasu('Propositions')
    def _propositions_(self):  # noqa
        with self._optional():
            with self._optional():
                self._long_name_()
            with self._optional():
                self._content_square_bracket_()
            self._token(':')
        self.name_last_node('main_name')

        def block2():
            with self._group():
                with self._choice():
                    with self._option():
                        self._term_var_()
                    with self._option():
                        self._long_name_()
                    with self._option():
                        self._content_open_closed_()
                    with self._option():
                        self._is_pattern_()
                    self._error('expecting one of: content_open_closed is_pattern long_name term_var')
        self._positive_closure(block2)
        self.name_last_node('main_conts')

        def block5():
            self._token('and')
            with self._optional():
                with self._optional():
                    self._long_name_()
                with self._optional():
                    self._content_square_bracket_()
                self._token(':')

            def block6():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._term_var_()
                        with self._option():
                            self._long_name_()
                        with self._option():
                            self._content_open_closed_()
                        with self._option():
                            self._is_pattern_()
                        self._error('expecting one of: content_open_closed is_pattern long_name term_var')
            self._positive_closure(block6)
        self._closure(block5)
        self.name_last_node('more_conts')
        with self._optional():
            self._token('if')
            self._propositions_()
        self.name_last_node('if_if')
        with self._optional():
            self._token('for')
            self._variables_()
        self.name_last_node('for_vars')
        self.ast._define(
            ['for_vars', 'if_if', 'main_conts', 'main_name', 'more_conts'],
            []
        )

    @tatsumasu('Variables')
    def _variables_(self):  # noqa
        self._long_name_()
        self.name_last_node('main_var')
        with self._optional():
            self._token('::')
            self._type_()
        self.name_last_node('main_type')
        with self._optional():
            self._mixfix_()
        self.name_last_node('mixfix')

        def block4():
            with self._optional():
                self._token('and')
            self._long_name_()
            with self._optional():
                self._token('::')
                self._type_()
            with self._optional():
                self._mixfix_()
        self._closure(block4)
        self.name_last_node('more_vars')
        self.ast._define(
            ['main_type', 'main_var', 'mixfix', 'more_vars'],
            []
        )

    @tatsumasu()
    def _type_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._long_name_()
                with self._option():
                    self._type_ident_()
                with self._option():
                    self._int_str_()
                with self._option():
                    self._content_open_closed_()
                self._error('expecting one of: /"(.|\\n)*?(?<!\\\\)"/ /\'([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /((?P>name)\\.)+(?P<name>([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>))/ /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /(\\\\<open>)((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?R))*(\\\\<close>)/ /-?( )*[0-9]+/ /[\\*_#&$]+/ /\\\\<([A-Za-z][A-Za-z0-9_\']*)>/ /\\{\\*(.|\\n)*?\\*\\}/ content_double_quotation content_open_closed int_str long_name name type_ident')

    @tatsumasu()
    def _type_ident_(self):  # noqa
        self._pattern("'([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)")

    @tatsumasu()
    def _term_var_(self):  # noqa
        self._pattern("\\?([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)(\\.[0-9]+)?")

    @tatsumasu()
    def _type_var_(self):  # noqa
        self._pattern("\\?'[A-Za-z][A-Za-z0-9_']*")

    @tatsumasu('TextBlock')
    def _text_block_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('section')
                        with self._option():
                            self._token('subsection')
                        with self._option():
                            self._token('subsubsection')
                        with self._option():
                            self._token('paragraph')
                        with self._option():
                            self._token('chapter')
                        with self._option():
                            self._token('text')
                        self._error('expecting one of: chapter paragraph section subsection subsubsection text')
                self.name_last_node('key')
                with self._optional():
                    self._content_bracket_()
                self.name_last_node('opt')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._content_open_closed_()
                        with self._option():
                            self._name_()
                        self._error('expecting one of: content_open_closed name')
                self.name_last_node('cont')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('ML_file')
                        with self._option():
                            self._token('ML_val')
                        with self._option():
                            self._token('ML')
                        self._error('expecting one of: ML ML_file ML_val')
                self.name_last_node('key')
                with self._optional():
                    self._content_bracket_()
                self.name_last_node('opt')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._content_open_closed_()
                        with self._option():
                            self._long_name_()
                        self._error('expecting one of: content_open_closed long_name')
                self.name_last_node('cont')
            self._error('expecting one of: ML ML_file ML_val chapter paragraph section subsection subsubsection text')
        self.ast._define(
            ['cont', 'key', 'opt'],
            []
        )

    @tatsumasu('FactReference')
    def _fact_reference_(self):  # noqa
        with self._choice():
            with self._option():
                self._long_name_()
                self.name_last_node('fact_name')
                with self._optional():
                    self._selection_()
                self.name_last_node('sel')
                with self._optional():
                    self._forward_modifier_()
                self.name_last_node('for_mod')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._cartouche_()
                        with self._option():
                            self._back_quote_()
                        self._error('expecting one of: back_quote cartouche')
                self.name_last_node('cont')
                with self._optional():
                    self._forward_modifier_()
                self.name_last_node('for_mod')
            self._error("expecting one of: /((?P>name)\\.)+(?P<name>([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>))/ /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /(\\\\<open>)((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?0))*(\\\\<close>)/ /-?( )*[0-9]+/ /[\\*_#&$]+/ /\\\\<([A-Za-z][A-Za-z0-9_']*)>/ /`(.|\\n)*?`/ back_quote cartouche content_double_quotation int_str long_name name")
        self.ast._define(
            ['cont', 'fact_name', 'for_mod', 'sel'],
            []
        )

    @tatsumasu()
    def _cartouche_(self):  # noqa
        self._pattern('(\\\\<open>)((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?0))*(\\\\<close>)')

    @tatsumasu()
    def _back_quote_(self):  # noqa
        self._pattern('`(.|\\n)*?`')

    @tatsumasu('ForwardModifier')
    def _forward_modifier_(self):  # noqa
        self._token('[')

        def sep1():
            with self._group():
                self._token(',')

        def block1():
            self._single_forward_()
        self._join(block1, sep1)
        self.name_last_node('cont')
        self._token(']')
        self.ast._define(
            ['cont'],
            []
        )

    @tatsumasu()
    def _single_forward_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('OF')
                        with self._option():
                            self._token('THEN')
                        with self._option():
                            self._token('folded')
                        with self._option():
                            self._token('unfolded')
                        with self._option():
                            self._token('simplified')
                        with self._option():
                            self._token('case_product')
                        with self._option():
                            self._token('to_pred')
                        with self._option():
                            self._token('to_set')
                        with self._option():
                            self._token('FCOMP')
                        self._error('expecting one of: FCOMP OF THEN case_product folded simplified to_pred to_set unfolded')
                self.name_last_node('key')
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._content_square_bracket_()
                        with self._option():
                            self._content_bracket_()
                        self._error('expecting one of: content_bracket content_square_bracket')
                self.name_last_node('opt')

                def block5():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('_')
                            with self._option():
                                self._fact_reference_()
                            self._error('expecting one of: _ fact_reference')
                self._closure(block5)
                self.name_last_node('facts')
            with self._option():
                self._token('where')
                self.name_last_node('key')
                self._instantiations_()
                self.name_last_node('where_arg')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('rotated')
                        with self._option():
                            self._token('consumes')
                        self._error('expecting one of: consumes rotated')
                self.name_last_node('key')
                with self._optional():
                    self._integer_()
                self.name_last_node('rotated_arg')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('case_names')
                        with self._option():
                            self._token('case_conclusion')
                        self._error('expecting one of: case_conclusion case_names')
                self.name_last_node('key')

                def block15():
                    self._long_name_()
                self._positive_closure(block15)
                self.name_last_node('case_args')
            with self._option():
                self._token('internalize_sort')
                self.name_last_node('key')
                self._content_open_closed_()
                self.name_last_node('internalize_sort_args')
            with self._option():
                self._token('of')
                self.name_last_node('key')

                def block20():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('_')
                            with self._option():
                                self._token('for')
                            with self._option():
                                self._token('concl')
                            with self._option():
                                self._token('and')
                            with self._option():
                                self._token('::')
                            with self._option():
                                self._token(':')
                            with self._option():
                                self._long_name_()
                            with self._option():
                                self._term_var_()
                            with self._option():
                                self._content_open_closed_()
                            with self._option():
                                self._int_str_()
                            self._error('expecting one of: : :: _ and concl content_open_closed for int_str long_name term_var')
                self._closure(block20)
                self.name_last_node('of_arg')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('rule_format')
                            with self._optional():
                                self._content_bracket_()
                        with self._option():
                            self._token('iff')
                        with self._option():
                            self._token('split_format')
                            with self._optional():
                                self._content_bracket_()
                        with self._option():
                            self._token('split_rule')
                        with self._option():
                            self._token('symmetric')
                        with self._option():
                            self._token('abs_def')
                        with self._option():
                            self._token('elim_format')
                        with self._option():
                            self._token('simp')
                            self._token('del')
                        with self._option():
                            self._token('simp')
                            self._token('add')
                        with self._option():
                            self._token('simp')
                        with self._option():
                            self._token('intro')
                            self._token('!')
                        with self._option():
                            self._token('intro')
                            self._token('?')
                        with self._option():
                            self._token('intro')
                        with self._option():
                            self._token('Pure.intro')
                        with self._option():
                            self._token('to_set')
                        with self._option():
                            self._token('pred_set_conv')
                        with self._option():
                            self._token('mono_set')
                        with self._option():
                            self._token('arith')
                        with self._option():
                            self._token('transfer_rule')
                            self._token('del')
                        with self._option():
                            self._token('transfer_rule')
                        with self._option():
                            self._token('tendsto_intros')
                        with self._option():
                            self._token('Transfer.transferred')
                        with self._option():
                            self._token('measurable')
                            with self._optional():
                                with self._choice():
                                    with self._option():
                                        self._token('del')
                                    with self._option():
                                        self._token('add')
                                    with self._option():
                                        self._content_bracket_()
                                    self._error('expecting one of: add content_bracket del')
                        with self._option():
                            self._token('measurable_dest')
                        with self._option():
                            self._token('measurable_cong')
                        with self._option():
                            self._token('cong')
                            self._token('del')
                        with self._option():
                            self._token('cong')
                            self._token('add')
                        with self._option():
                            self._token('cong')
                        with self._option():
                            self._token('derivative_intros')
                        with self._option():
                            self._token('dest')
                            self._token('!')
                        with self._option():
                            self._token('dest')
                            self._token('?')
                        with self._option():
                            self._token('dest')
                        with self._option():
                            self._token('trans')
                        with self._option():
                            self._token('elim')
                            self._token('!')
                        with self._option():
                            self._token('elim')
                            self._token('?')
                        with self._option():
                            self._token('elim')
                        with self._option():
                            self._token('arith_split')
                        with self._option():
                            self._token('temp_use')
                        with self._option():
                            self._token('try_rewrite')
                        with self._option():
                            self._token('cancel_type_definition')
                        with self._option():
                            self._token('untransferred')
                        with self._option():
                            self._token('param_fo')
                        with self._option():
                            self._token('eqvt')
                        with self._option():
                            self._token('eqvt_raw')
                        with self._option():
                            self._token('relator_eq')
                        with self._option():
                            self._token('to_hnr')
                        with self._option():
                            self._token('interaction_bound')
                        with self._option():
                            self._token('refine')
                            with self._optional():
                                self._token('del')
                        with self._option():
                            self._token('refine_dref_RELATES')
                        with self._option():
                            self._token('sepref_import_param')
                        with self._option():
                            self._token('split')
                        with self._option():
                            self._token('le')
                        with self._option():
                            self._token('refine_vcg_def')
                        with self._option():
                            self._token('refine_vcg')
                        with self._option():
                            self._token('equiv_lr')
                        with self._option():
                            self._token('conj1')
                        with self._option():
                            self._token('conj2')
                        with self._option():
                            self._token('axiom_instance')
                        with self._option():
                            self._token('cancel_card_constraint')
                        with self._option():
                            self._token('axiom_necessitation')
                        with self._option():
                            self._token('equiv_rl')
                        with self._option():
                            self._token('deduction')
                        with self._option():
                            self._token('axiom_instance')
                        with self._option():
                            self._token('necessitation_averse_axiom_instance')
                        with self._option():
                            self._token('axiom_actualization')
                        with self._option():
                            self._token('axiom_universal')
                        with self._option():
                            self._token('equiv_sym')
                        with self._option():
                            self._token('conj_sym')
                        with self._option():
                            self._token('eq_sym')
                        with self._option():
                            self._token('cases')
                            self._token('set')
                        with self._option():
                            self._token('sepref_prep_comb_rule')
                        with self._option():
                            self._token('unlifted')
                        with self._option():
                            self._token('int_rewrite')
                        with self._option():
                            self._token('unlift_rule')
                        with self._option():
                            self._token('sep_heap_rules')
                        self._error('expecting one of: Pure.intro Transfer.transferred abs_def arith arith_split axiom_actualization axiom_instance axiom_necessitation axiom_universal cancel_card_constraint cancel_type_definition cases cong conj1 conj2 conj_sym deduction derivative_intros dest elim elim_format eq_sym equiv_lr equiv_rl equiv_sym eqvt eqvt_raw iff int_rewrite interaction_bound intro le measurable measurable_cong measurable_dest mono_set necessitation_averse_axiom_instance param_fo pred_set_conv refine refine_dref_RELATES refine_vcg refine_vcg_def relator_eq rule_format sep_heap_rules sepref_import_param sepref_prep_comb_rule simp split split_format split_rule symmetric temp_use tendsto_intros to_hnr to_set trans transfer_rule try_rewrite unlift_rule unlifted untransferred')
                self.name_last_node('key')
            self._error('expecting one of: FCOMP OF Pure.intro THEN Transfer.transferred abs_def arith arith_split axiom_actualization axiom_instance axiom_necessitation axiom_universal cancel_card_constraint cancel_type_definition case_conclusion case_names case_product cases cong conj1 conj2 conj_sym consumes deduction derivative_intros dest elim elim_format eq_sym equiv_lr equiv_rl equiv_sym eqvt eqvt_raw folded iff int_rewrite interaction_bound internalize_sort intro le measurable measurable_cong measurable_dest mono_set necessitation_averse_axiom_instance of param_fo pred_set_conv refine refine_dref_RELATES refine_vcg refine_vcg_def relator_eq rotated rule_format sep_heap_rules sepref_import_param sepref_prep_comb_rule simp simplified split split_format split_rule symmetric temp_use tendsto_intros to_hnr to_pred to_set trans transfer_rule try_rewrite unfolded unlift_rule unlifted untransferred where')
        self.ast._define(
            ['case_args', 'facts', 'internalize_sort_args', 'key', 'of_arg', 'opt', 'rotated_arg', 'where_arg'],
            []
        )

    @tatsumasu()
    def _name_(self):  # noqa
        self._pattern("([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)")
        self._check_name()

    @tatsumasu()
    def _free_name_(self):  # noqa
        self._pattern("[A-Za-z][A-Za-z0-9_']*")

    @tatsumasu()
    def _rat_str_(self):  # noqa
        self._pattern('-?( )*([0-9]*\\.)?[0-9]+')

    @tatsumasu()
    def _int_str_(self):  # noqa
        self._pattern('-?( )*[0-9]+')

    @tatsumasu('int')
    def _integer_(self):  # noqa
        self._pattern('-?( )*[0-9]+')

    @tatsumasu('Selection')
    def _selection_(self):  # noqa
        self._token('(')

        def sep1():
            with self._group():
                self._token(',')

        def block1():
            self._integer_()
            with self._optional():
                self._token('-')
                with self._optional():
                    self._integer_()
        self._join(block1, sep1)
        self.name_last_node('cont')
        self._token(')')
        self.ast._define(
            ['cont'],
            []
        )

    @tatsumasu()
    def _long_name_(self):  # noqa
        with self._choice():
            with self._option():
                self._content_double_quotation_()
            with self._option():
                self._pattern("((?P>name)\\.)+(?P<name>([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>))")
            with self._option():
                self._pattern('[\\*_#&$]+')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._int_str_()
                        self._error("expecting one of: /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /-?( )*[0-9]+/ int_str name")
            with self._option():
                self._pattern("\\\\<([A-Za-z][A-Za-z0-9_']*)>")
            self._error('expecting one of: /"(.|\\n)*?(?<!\\\\)"/ /((?P>name)\\.)+(?P<name>([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>))/ /([A-Za-z]|\\\\<(?P<sp>alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega|[A-Za-z]{1,2})>)([A-Za-z0-9_\']|\\\\<(\\^sub|(?P>sp))>)*(?<!\\\\<\\^sub>)/ /-?( )*[0-9]+/ /[\\*_#&$]+/ /\\\\<([A-Za-z][A-Za-z0-9_\']*)>/ content_double_quotation int_str name')
        self._check_name()

    @tatsumasu()
    def _ignored_diag_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('thm')

                def block0():
                    self._fact_reference_()
                self._positive_closure(block0)
            with self._option():
                self._token('print_cases')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('nitpick')
                        with self._option():
                            self._token('quickcheck')
                        self._error('expecting one of: nitpick quickcheck')
                with self._optional():
                    self._content_square_bracket_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('section')
                        with self._option():
                            self._token('subsection')
                        with self._option():
                            self._token('subsubsection')
                        with self._option():
                            self._token('paragraph')
                        with self._option():
                            self._token('chapter')
                        with self._option():
                            self._token('text')
                        with self._option():
                            self._token('txt')
                        self._error('expecting one of: chapter paragraph section subsection subsubsection text txt')
                with self._optional():
                    self._content_bracket_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._content_open_closed_()
                        with self._option():
                            self._name_()
                        self._error('expecting one of: content_open_closed name')
            self._error('expecting one of: chapter nitpick paragraph print_cases quickcheck section subsection subsubsection text thm txt')

    @tatsumasu('DiagStatement')
    def _diag_statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('record_facts')
                self.name_last_node('key')
                self._token('(')

                def block2():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('-')
                            with self._option():
                                self._name_()
                            with self._option():
                                self._content_open_closed_()
                            self._error('expecting one of: - content_open_closed name')
                self._positive_closure(block2)
                self.name_last_node('attrs')
                self._token(')')
                self._fact_reference_()
                self.name_last_node('fact_ref')
                with self._optional():
                    self._content_open_closed_()
                self.name_last_node('txt')
            with self._option():
                self._token('record_all_facts')
                self.name_last_node('key')
                self._token('(')

                def block8():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('-')
                            with self._option():
                                self._name_()
                            with self._option():
                                self._content_open_closed_()
                            self._error('expecting one of: - content_open_closed name')
                self._positive_closure(block8)
                self.name_last_node('attrs')
                self._token(')')
            with self._option():
                self._token('check_derivation')
                self.name_last_node('key')
                self._token('(')

                def block12():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('-')
                            with self._option():
                                self._name_()
                            with self._option():
                                self._content_open_closed_()
                            self._error('expecting one of: - content_open_closed name')
                self._positive_closure(block12)
                self.name_last_node('attrs')
                self._token(')')
                self._content_open_closed_()
                self.name_last_node('raw_seq')
                self._fact_reference_()
                self.name_last_node('fact_ref')
                self._token('(')

                def block17():
                    self._fact_reference_()
                self._closure(block17)
                self.name_last_node('fact_asms')
                self._token(')')
            with self._option():
                self._token('check_derivation_C')
                self.name_last_node('key')
                self._token('(')

                def block20():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('-')
                            with self._option():
                                self._name_()
                            with self._option():
                                self._content_open_closed_()
                            self._error('expecting one of: - content_open_closed name')
                self._positive_closure(block20)
                self.name_last_node('attrs')
                self._token(')')
                self._content_open_closed_()
                self.name_last_node('raw_seq')
                self._fact_reference_()
                self.name_last_node('fact_ref')
                self._fact_reference_()
                self.name_last_node('fact_ref2')
                self._token('(')

                def block26():
                    self._fact_reference_()
                self._closure(block26)
                self.name_last_node('fact_asms')
                self._token(')')
            self._error('expecting one of: check_derivation check_derivation_C record_all_facts record_facts')
        self.ast._define(
            ['attrs', 'fact_asms', 'fact_ref', 'fact_ref2', 'key', 'raw_seq', 'txt'],
            []
        )

    @tatsumasu()
    def _content_bracket_(self):  # noqa
        self._pattern('\\((\\\\<open>(.|\\n)*?\\\\<close>|"(.|\\n)*?(?<!\\\\)"|(?!(\\(|\\)))(.|\\n)|(?R))*\\)')

    @tatsumasu()
    def _content_square_bracket_(self):  # noqa
        self._pattern('(\\[)((?!(\\[|\\]))(.|\\n)|(?R))*(\\])')

    @tatsumasu()
    def _double_square_bracket_(self):  # noqa
        self._pattern('\\[[ \\n]*\\[((?!(\\[|\\]))(.|\\n))*?\\][ \\n]*\\]')

    @tatsumasu()
    def _content_open_closed_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('(\\\\<open>)((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?R))*(\\\\<close>)')
            with self._option():
                self._pattern('"(.|\\n)*?(?<!\\\\)"')
            with self._option():
                self._pattern('\\{\\*(.|\\n)*?\\*\\}')
            self._error('expecting one of: /"(.|\\n)*?(?<!\\\\)"/ /(\\\\<open>)((?!(\\\\<open>|\\\\<close>))(.|\\n)|(?R))*(\\\\<close>)/ /\\{\\*(.|\\n)*?\\*\\}/')

    @tatsumasu()
    def _content_double_quotation_(self):  # noqa
        self._pattern('"(.|\\n)*?(?<!\\\\)"')

    @tatsumasu()
    def _content_begin_end_(self):  # noqa
        self._pattern('(?P<b>(?<=( |\\n))begin(?=( |\\n)))((?!((?P>b)|(?P>e)))(.|\\n)|(?R))*((?P<e>(?<=( |\\n))end(?=( |\\n))))')

    @tatsumasu()
    def _content_proof_qed_(self):  # noqa
        self._pattern('(?P<b>(?<=( |\\n))proof(?=( |\\n)))((?!((?P>b)|(?P>e)))(.|\\n)|(?R))*((?P<e>(?<=( |\\n))qed(?=( |\\n))))')


class ThySemantics(object):
    def start(self, ast):  # noqa
        return ast

    def theory(self, ast):  # noqa
        return ast

    def thy_keywords(self, ast):  # noqa
        return ast

    def imported_thy_name(self, ast):  # noqa
        return ast

    def theory_statement(self, ast):  # noqa
        return ast

    def extra_context(self, ast):  # noqa
        return ast

    def extra_thy_command(self, ast):  # noqa
        return ast

    def sublocale(self, ast):  # noqa
        return ast

    def theorem(self, ast):  # noqa
        return ast

    def locale_class(self, ast):  # noqa
        return ast

    def context(self, ast):  # noqa
        return ast

    def named_theorems(self, ast):  # noqa
        return ast

    def definition(self, ast):  # noqa
        return ast

    def quanlifier(self, ast):  # noqa
        return ast

    def function(self, ast):  # noqa
        return ast

    def termination(self, ast):  # noqa
        return ast

    def theorem_statement(self, ast):  # noqa
        return ast

    def precondition(self, ast):  # noqa
        return ast

    def is_pattern(self, ast):  # noqa
        return ast

    def mixfix(self, ast):  # noqa
        return ast

    def proof_block(self, ast):  # noqa
        return ast

    def proof_qed(self, ast):  # noqa
        return ast

    def refinement_step(self, ast):  # noqa
        return ast

    def closing_step(self, ast):  # noqa
        return ast

    def subgoal_block(self, ast):  # noqa
        return ast

    def isar_statement(self, ast):  # noqa
        return ast

    def pre_facts(self, ast):  # noqa
        return ast

    def tactic(self, ast):  # noqa
        return ast

    def single_tactic(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def instantiations(self, ast):  # noqa
        return ast

    def instantiation(self, ast):  # noqa
        return ast

    def induct_modifier(self, ast):  # noqa
        return ast

    def tactic_modifier(self, ast):  # noqa
        return ast

    def propositions(self, ast):  # noqa
        return ast

    def variables(self, ast):  # noqa
        return ast

    def type(self, ast):  # noqa
        return ast

    def type_ident(self, ast):  # noqa
        return ast

    def term_var(self, ast):  # noqa
        return ast

    def type_var(self, ast):  # noqa
        return ast

    def text_block(self, ast):  # noqa
        return ast

    def fact_reference(self, ast):  # noqa
        return ast

    def cartouche(self, ast):  # noqa
        return ast

    def back_quote(self, ast):  # noqa
        return ast

    def forward_modifier(self, ast):  # noqa
        return ast

    def single_forward(self, ast):  # noqa
        return ast

    def name(self, ast):  # noqa
        return ast

    def free_name(self, ast):  # noqa
        return ast

    def rat_str(self, ast):  # noqa
        return ast

    def int_str(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def selection(self, ast):  # noqa
        return ast

    def long_name(self, ast):  # noqa
        return ast

    def ignored_diag(self, ast):  # noqa
        return ast

    def diag_statement(self, ast):  # noqa
        return ast

    def content_bracket(self, ast):  # noqa
        return ast

    def content_square_bracket(self, ast):  # noqa
        return ast

    def double_square_bracket(self, ast):  # noqa
        return ast

    def content_open_closed(self, ast):  # noqa
        return ast

    def content_double_quotation(self, ast):  # noqa
        return ast

    def content_begin_end(self, ast):  # noqa
        return ast

    def content_proof_qed(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'start'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = ThyParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, ThyParser, name='Thy')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
